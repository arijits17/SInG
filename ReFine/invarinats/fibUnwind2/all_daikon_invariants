Daikon version 5.6.4, released April 3, 2018; http://plse.cs.washington.edu/daikon.
Reading declaration files Processing trace data; reading 3 dtrace files:

===========================================================================
..main():::ENTER
::i == ::j
::i == argc
::i == 1
::ct == 0
argv != null
===========================================================================
..main():::EXIT
::ct == return
::ct == orig(::ct)
::ct == 0
::i > ::ct
::i > orig(::i)
::j > ::ct
::j > orig(::i)
===========================================================================
..read_i11():::ENTER
::i == 1
::j one of { 1, 2 }
::ct == 0
::i <= ::j
::j > ::ct
===========================================================================
..read_i11():::EXIT
::i == return
::i == orig(::i)
::j == orig(::j)
::ct == orig(::ct)
::i == 1
::j one of { 1, 2 }
::ct == 0
::i <= ::j
::j > ::ct
===========================================================================
..read_i12():::ENTER
::i one of { 2, 3, 4 }
::j one of { 1, 2, 3 }
::ct == 0
::i > ::ct
::j > ::ct
===========================================================================
..read_i12():::EXIT
::i == return
::i == orig(::i)
::j == orig(::j)
::ct == orig(::ct)
::i one of { 2, 3, 4 }
::j one of { 1, 2, 3 }
::ct == 0
::i > ::ct
::j > ::ct
===========================================================================
..read_i21():::ENTER
::i one of { 1, 2, 3 }
::j == 1
::ct == 0
::i >= ::j
::i > ::ct
===========================================================================
..read_i21():::EXIT
::i == return
::j == orig(::j)
::ct == orig(::ct)
::i one of { 1, 2, 3 }
::j == 1
::ct == 0
::i >= ::j
::i > ::ct
::i >= orig(::i)
::j <= orig(::i)
::ct < orig(::i)
===========================================================================
..read_i22():::ENTER
::i >= 1
::j one of { 2, 3, 4 }
::ct == 0
::i > ::ct
::j > ::ct
===========================================================================
..read_i22():::EXIT
::i == return
::j == orig(::j)
::ct == orig(::ct)
::i >= 1
::j one of { 2, 3, 4 }
::ct == 0
::i > ::ct
::i >= orig(::i)
::j > ::ct
::ct < orig(::i)
===========================================================================
..read_j11():::ENTER
::i == 1
::j one of { 1, 2 }
::ct == 0
::i <= ::j
::j > ::ct
===========================================================================
..read_j11():::EXIT
::i == orig(::i)
::j == return
::ct == orig(::ct)
::i == 1
::j one of { 1, 2, 3 }
::ct == 0
::i <= ::j
::i <= orig(::j)
::j > ::ct
::j >= orig(::j)
::ct < orig(::j)
===========================================================================
..read_j12():::ENTER
::i one of { 2, 3, 4 }
::j one of { 1, 2, 3 }
::ct == 0
::i > ::ct
::j > ::ct
===========================================================================
..read_j12():::EXIT
::i == orig(::i)
::j == return
::ct == orig(::ct)
::i one of { 2, 3, 4 }
::j >= 1
::ct == 0
::i > ::ct
::j > ::ct
::j >= orig(::j)
::ct < orig(::j)
===========================================================================
..read_j21():::ENTER
::i one of { 1, 2, 3 }
::j == 1
::ct == 0
::i >= ::j
::i > ::ct
===========================================================================
..read_j21():::EXIT
::j == return
::j == orig(::j)
::ct == orig(::ct)
::i one of { 1, 2, 3 }
::j == 1
::ct == 0
::i >= ::j
::i > ::ct
::i >= orig(::i)
::j <= orig(::i)
::ct < orig(::i)
===========================================================================
..read_j22():::ENTER
::i >= 1
::j one of { 2, 3, 4 }
::ct == 0
::i > ::ct
::j > ::ct
===========================================================================
..read_j22():::EXIT
::j == return
::j == orig(::j)
::ct == orig(::ct)
::i >= 1
::j one of { 2, 3, 4 }
::ct == 0
::i > ::ct
::i >= orig(::i)
::j > ::ct
::ct < orig(::i)
===========================================================================
..t1():::ENTER
::i == 1
::j one of { 1, 2 }
::ct == 0
arg == null
::i <= ::j
::j > ::ct
===========================================================================
..t1():::EXIT
::ct == orig(::ct)
return == orig(arg)
::j >= 1
::ct == 0
return == null
::i >= ::j
::i > ::ct
::i > orig(::i)
::i > orig(::j)
::j > ::ct
::j >= orig(::i)
::j >= orig(::j)
::ct < orig(::j)
===========================================================================
..t2():::ENTER
::i one of { 1, 2, 3 }
::j == 1
::ct == 0
arg == null
::i >= ::j
::i > ::ct
===========================================================================
..t2():::EXIT
::ct == orig(::ct)
return == orig(arg)
::i >= 1
::ct == 0
return == null
::i > ::ct
::i >= orig(::i)
::i >= orig(::j)
::j > ::ct
::j > orig(::i)
::j > orig(::j)
::ct < orig(::i)
Exiting Daikon.
